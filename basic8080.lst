0000                          ; Will Stevens
0000                          ; 25th Feb 2023
0000                          ; 1K 8080 BASIC
0000                          ; GPL v3
0000                          ; 
0000                          ; Terminal settings:
0000                          ; 
0000                          ; Assumes that outputting a newline requires
0000                          ; CR and LF, and that pressing return on the
0000                          ; terminal sends CR and LF. 1K BASIC echoes all
0000                          ; characters it receives back to the terminal.
0000                          ; I believe that these settings are compatible
0000                          ; with using a Teletype Model 33 in full duplex
0000                          ; mode.
0000                          ; 
0000                          ; Post-assembly checklist
0000                          ; 
0000                          ; 1. LineNumSub is >= address 223h
0000                          ; 2. DivSub is <= address 2ffh
0000                          ; 3. DivJzError is at address 3xxh
0000                          ; 4. In LineStartsWithInt, the jump to
0000                          ;    DeleteProgramLine is on the same
0000                          ;    page as DeleteProgramLine
0000                          ; 5. Program does not exceed 1k
0000                          ; 6. In ClassLookup, check that QuoteClass
0000                          ;    has LSBit different from othet class
0000                          ;    routines.
0000                          ; 7. Ready is at address 00DE
0000                          ; 8. Code before 'Ready:' does not overlap with
0000                          ;    'Ready:', Can be seen from the HEX file.
0000                          ; 
0000                          ; Development log:
0000                          ; 2023-03-03 About 450 bytes long
0000                          ; 2023-03-08 About 750 bytes long
0000                          ; 2023-03-11 About 840 bytes long
0000                          ; 2023-03-12 About 930 bytes long.
0000                          ;   String tokens added.
0000                          ;   * and / yet to be added.
0000                          ;   Some scope for size optimization.
0000                          ; 2023-03-12 About 940 bytes long
0000                          ;		* added
0000                          ;		some reduction in code size done
0000                          ; 2023-03-16 About 970 bytes long
0000                          ;   unsigned / and integer output added
0000                          ;		about 30 bytes could be saved
0000                          ;		by using RST in place of call
0000                          ;   in some places
0000                          ; 2023-03-17 About 940 bytes long
0000                          ; 2023-03-17 About 970 bytes long
0000                          ;		INPUT added
0000                          ; 2023-03-19 About 960 bytes long
0000                          ;    some bug fixes
0000                          ;		 capable of playing lunar lander
0000                          ; 2023-03-22 About 970 bytes long
0000                          ;		 signed / added
0000                          ; 2023-03-24 About 950 bytes long
0000                          ;		 more code size reductions
0000                          ;		 signed integer parsing supported
0000                          ; 2023-03-24 About 940 bytes long
0000                          ;    more code size reductions
0000                          ; 2023-03-27 About 950 bytes long
0000                          ;		 simplified operator calling and
0000                          ;		 simplified a few operators
0000                          ;		 working on memory rotate function needed
0000                          ;		 for line deletion and insertion
0000                          ; 2023-04-09 About 970 bytes long.
0000                          ;		 more code size reductions
0000                          ;		 first draft of memory rotate function added
0000                          ; 2023-04-12 About 995 bytes long
0000                          ;		 line deletion function more complete
0000                          ;		 looking for better way of decreasing
0000                          ;		 PROG_PTR after line deletion
0000                          ; 2023-04-16 About 986 bytes long
0000                          ;    line deletion apparently working
0000                          ;    some code size reductions
0000                          ; 2023-04-16 About 963 bytes long
0000                          ;			further code size reductions
0000                          ; 2023-04-17 About 930 bytes long
0000                          ;			looked for subroutine code sharing and
0000                          ;			LXI trick optimisations.
0000                          ;			Likely that some bugs will have been
0000                          ;			introduced when doing this
0000                          ; 2023-04-18 About 900 bytes long
0000                          ;			greatly reduced CharClass size
0000                          ; 2023-04-20 About 880 bytes long
0000                          ;			more code size reduction
0000                          ; 2023-04-23 About 970 bytes long
0000                          ;			first draft of code for LIST added
0000                          ; 2023-04-25 About 970 bytes long
0000                          ;			LIST command working
0000                          ; 2023-04-27 About 950 bytes long
0000                          ;			More code size reduction
0000                          ; 2023-04-28 About 950 bytes long
0000                          ;			used RST_CompareJump to save
0000                          ;			2 bytes for every CPI JZ where
0000                          ;			the jump is to same page
0000                          ; 2023-04-28 Free space: 78 bytes
0000                          ; 2023-04-29 Free space: 84 bytes
0000                          ;			Initialise PROG_PTR at start
0000                          ;			Added NEW and END
0000                          ;			Added direct statement handling
0000                          ; 2023-04-30 Free space: 86 bytes
0000                          ;			Fixed bugs with deleting first and
0000                          ;			last program lines
0000                          ; 2023-05-02 Free space: about 60 bytes
0000                          ;			added code to allow out-of-order
0000                          ;			line number entry (first draft)
0000                          ; 2023-05-02 Free space: about 54 bytes
0000                          ;			all basic functionality now implemented
0000                          ;			items to improve:
0000                          ;			division
0000                          ;			syntax checking
0000                          ; 2023-05-04 Free space: about 79 bytes
0000                          ;			more code size reduction
0000                          ;			partly through handling EndProgram
0000                          ;			and LineNum better in threaded code
0000                          ;			likely to have introduced bugs
0000                          ; 2023-05-07 Free space: about 69 bytes
0000                          ;			Improved expression evaluation by
0000                          ;			making it recursively callable
0000                          ;			and no longer requiring operator stack
0000                          ;			and about 20 bytes shorter.
0000                          ;			Used freed space for more syntax checks
0000                          ; 2023-05-08 Free space: about 44 bytes
0000                          ;			First draft of support for array var @
0000                          ; 2023-05-17 Free space: About 100 bytes
0000                          ;			First draft of new parser from
0000                          ;			experiments/parsing3.asm.
0000                          ;			Still need to modify string representation
0000                          ;			and change how INPUT parses integer,
0000                          ;			and check string token doesn't interfere
0000                          ;			after TokenList, and check order in
0000                          ;			TokenList.
0000                          ;			Seems likely that enough space has been
0000                          ;			freed to be able to implement FOR...NEXT
0000                          ; 2023-05-19 Free space: About 101 bytes
0000                          ;			Issues listed above have been addressed now
0000                          ;			Testing needed to iron out problems
0000                          ; 2023-05-26 Free space: About 84 bytes
0000                          ;			various bug fixes
0000                          ;			PRINT allows comma at end to suppress
0000                          ;			newline.
0000                          ;			Show > prompt symbol when ready.
0000                          ; 2023-05-27 Free space: About 17 bytes
0000                          ;			Added FOR NEXT (no STEP yet)
0000                          ;			Need more space
0000                          ; 2023-05-27 Free space: About 36 bytes
0000                          ;			Made a few small byte savings, and put
0000                          ;			token subs onto page 2 so that last one
0000                          ;			can flow onto page 3, freeing some space
0000                          ;			in page 2 to avoid having to jump out.
0000                          ;			One TODO to action
0000                          ; 2023-05-28 Free space: About 42 bytes
0000                          ; 2023-05-29 Free space: About 53 bytes
0000                          ;			Made some changes to * and / which I hope
0000                          ;			are improvements (efficienxy + code size)
0000                          ;			but testing needed to confirm this.
0000                          ; 2023-06-02 Free space: About 12 bytes
0000                          ;			Added support for STEP to FOR loops
0000                          ;			Noted where Z flag is in known state
0000                          ;			in JMP instructions, because there is
0000                          ;			potential space saving by having
0000                          ;			2-byte in-page JMP, JNZ or JZ,
0000                          ;			code shared with RST_CompareJump
0000                          ; 2023-06-03 Free space: About 10 bytes
0000                          ;			STEP works in +ve direction only
0000                          ;			Fixing will require more space
0000                          ;			Would also like to add ABS, RND, USR
0000                          ;			But probably need about 60 bytes for that
0000                          ; 2023-06-03 Free space: About 19 bytes
0000                          ;			Added in-page JZ to free up space
0000                          ;			Likely to have introduced errors
0000                          ; 2023-06-04 Free space: About 25 bytes
0000                          ;			Shortened PrintSub
0000                          ; 2023-06-04 Free space: about -21 bytes
0000                          ;			Implementing ABS and USR and skeleton
0000                          ;		  of RND makes it 21 bytes over budget.
0000                          ;			So it seems reasonable to think that
0000                          ;			space can be made for these.
0000                          ; 2023-06-05 Free space: about -15 bytes
0000                          ; 2023-06-19 Free space: about 6 bytes
0000                          ;			Replaced memory rotate with triple reversal
0000                          ;			algorithm. Back below size limit, but need
0000                          ;		  to rearrange things to realize this.
0000                          ; 2023-06-22 Free space: about 10 bytes
0000                          ;			All free space is in the RST area, which I
0000                          ;     am reluctant to use because I expect that
0000                          ;			when I try to target actual hardware I will
0000                          ;			need to extend PutChar, and maybe have
0000                          ;			some initialization code for e.g. UART.
0000                          ;			So discounting this I am 2 bytes over
0000                          ;			budget, and haven't implemented RND
0000                          ;			function yet
0000                          ; 2023-06-23 Free space : 18 bytes
0000                          ;			Saved space with more sharing between
0000                          ; 		LET and INPUT
0000                          ;			Ready to do a lot of testing
0000                          ; 2023-06-28 Free space : 20 bytes
0000                          ; 2023-06-28 Free space : 19 bytes
0000                          ;			Fixed enough bugs that lunar lander works
0000                          ;			Function calls don't work yet
0000                          ; 2023-07-01 Free space : 24 bytes
0000                          ;			ABS function works
0000                          ;			RND function currently does nothing
0000                          ;			need to make implementation of RND
0000                          ;			that fits in 17 bytes
0000                          ; 2023-07-04 Free space : 20 bytes
0000                          ;			Implemented simple lookup-based RND
0000                          ;			replaced newline RST with LDAX B, INX B
0000                          ;			saved a few bytes in LIST
0000                          ; 2023-07-05 Free space : 11 bytes
0000                          ;			Implemented XORSHIFT RND function
0000                          ; 2023-07-08 Free space: 10 bytes
0000                          ; 2023-07-12 Free space: 15 bytes
0000                          ;			Fixed forgotten issue where STEP in FOR
0000                          ;			loop didn't work if negative
0000                          ; 2023-07-13 Free space: 13 bytes
0000                          ;			Extended variable range up to 32
0000                          ;			So that user has 31 variables and array
0000                          ;			var 30 can be used to work out
0000                          ;			remaining memory
0000                          ;			var 31 is RNG seed
0000                          ; 2023-07-15 Noticed bug where -32768 isn't
0000                          ;     displayed
0000                          ; 2023-07-15 When playing REVERSE, saw corrupted
0000                          ;			array, which implies that bug where stack
0000                          ;			continually growing
0000                          ; 2023-07-16 Above two issues fixed. Former
0000                          ;     required change to PrintInteger. Latter
0000                          ;			was due to a GOTO from within FOR loop,
0000                          ;			in REVERSE and not necessarily a problem
0000                          ;			with this interpreter
0000                          ; 2024-01-01 Fixed bug where parse error wasn't
0000                          ;     displayed as ? during LIST
0000                          ; 2024-01-28 Fixed bug where @ was displayed as M
0000                          ;     during LIST
0000                          ; 2024-02-07 Working on corrections to comparison
0000                          ;     operators. Not in working state. Made I/O
0000                          ;     compatible with Dick Whipple's Front Panel
0000                          ;     8080 simulator
0000                          ; 2024-02-08 May have fixed comparison operator
0000                          ;     problem. Need to save 2 bytes to be able to
0000                          ;     test it
0000                          ; 2024-02-08 Reclaimed some space so that 3FEh is
0000                          ;     the last byte uses. Free space 5 bytes.
0000                          ; 2024-02-18 Worked towards reclaiming 4 bytes in
0000                          ;     the tokenizer. Good chance of being
0000                          ;     incorrect, will require debugging.
0000                          ; 2024-02-20 Debugged above changes and
0000                          ;     they seem okau. Free space 9 bytes
0000                          ; 2024-02-22 Rearranged RSTs and added CPI to end
0000                          ;     of RST_LDAXB_INXB_CPI to save memory.
0000                          ;     Free space still 9 bytes but now
0000                          ;     7 of those are at the end of 1K, so are
0000                          ;     easy to make use of.
0000                          ;     Need to check movement and alignment
0000                          ;     of subroutines.
0000                          ;     It would be useful to have a checklist of
0000                          ;     all dependencies that need to be checked
0000                          ;     when there are large movements in memory.
0000                          ; 
0000                          ;     Next things to do:
0000                          ;     - unterminated string check
0000                          ;     - forbidding excess chars in tokens
0000                          ;     - correct operator precedence for * /
0000                          ;     - error on divide by zero
0000                          ;     not sure whether all 4 can be done in
0000                          ;     only 7 bytes
0000                          ; 2024-02-25 Added unterminated string check and
0000                          ;     didvide by zero error. 2 bytes over budget.
0000                          ; 2024-02-25 Realised that removing reatriction
0000                          ;     that RUN, LIST and NEW only allowed in
0000                          ;     direct mode would will probably save a
0000                          ;     sufficient number of bytes to finish all
0000                          ;     outstanding work
0000                          ; 2024-02-28 Sveral changes related to issues
0000                          ;     listed above, Divide by zero and
0000                          ;     unterminated string now generate error
0000                          ;     messages. 2 bytes free which should be
0000                          ;     enough to make * and / equal precedence,
0000                          ;     but will test everything else first. Issue
0000                          ;     about tokens with excess chars not being
0000                          ;     detected as errors will remain unfixed in
0000                          ;     first release.
0000                          ; 2024-03-01 Found bug where recent changes
0000                          ;     caused DeleteProgramLine to move page.
0000                          ;     In the course of fixing it, may have saved
0000                          ;     5 bytes. Need to test that fix is correct.
0000                          ; 2024-03-01 Fixed a bug introduced on 28 Feb
0000                          ;     where ExecuteDirect was called without
0000                          ;     setting B. Wrote 'game of life' example
0000                          ;     program. When printing newline, added CR
0000                          ;     before after discovering that some
0000                          ;     terminals need this. Need to free up
0000                          ;     1 byte to fix operator precedence issue
0000                          ; 2024-03-02 This version correcly runs
0000                          ;     lander.bas, reverse.bas, life.bas,
0000                          ;     operatortests.bas, operatortests2.bas,
0000                          ;     looptests.bas
0000                          ; 2024-03-02 Freed up 1 byte by removing
0000                          ;     redundant STC
0000                          ; 2024-03-03 Added code to make * same
0000                          ;     precedence as / (needs testing).
0000                          ;     Changed RNG from XORSHIFT to LCG.
0000                          ;     This saved 3 bytes.
0000                          ;     Need to experiment with LCG constant
0000                          ;     for best RNG performance.
0000                          ;     Behaviour of RNG function changed so
0000                          ;     that max valid input parameter is 256,
0000                          ;     because low order bits of RNG have
0000                          ;     low period. Only high ordet bits of
0000                          ;     RNG are used for return value.
0000                          ; 2024-03-04 Altered EndProgram address.
0000                          ;     Temporarily tried making RAM start at 1000h
0000                          ;     to check that this doesn't cause problems
0000                          ; 2024-03-06 Changed IO to support Stefan Tramms
0000                          ;     8080 emulator.
0000                          ; 2024-03-11 Moved start of RAM back to 0400h
0000                          ; 2024-03-12 Changed initialisation so that
0000                          ;     spurious char is no longer output on
0000                          ;     reset or NEW.
0000                          ; 2024-03-15 Realised during testing that
0000                          ;     ExpEvaluate can sometimes try to return
0000                          ;     when stack isn't a return address.
0000                          ;     Realised that ExpEvaluate must either
0000                          ;     succeed or fail, with no backtrack.
0000                          ;     This required substantial changes to
0000                          ;     PrintSub, especially a change to how it
0000                          ;     knows if it has just had a comma. This
0000                          ;     is now done based on parity of H.
0000                          ;     To be retested.
0000                          ; 
0000                          ;     Had an idea that operators and statements
0000                          ;     could reside on different pages, creating
0000                          ;     more space for both, and perhaps removing
0000                          ;     the need for some of the Jumps out of
0000                          ;     page 2 to statement implementation.
0000                          ;2024-03-23 Comment above won't be acted upon
0000                          ;     before version 1.0.
0000                          ;     Changed INPUT so that it doesn't display
0000                          ;     a prompt. It was confusing to have the
0000                          ;     > prompt as is used in direct mode. Instead
0000                          ;     programs that need a prompt before input
0000                          ;     can use the multistatement line
0000                          ;     PRINT "?", INPUT A
0000                          ; 
0000                          ; For development purposes assume we have
0000                          ; 1K ROM from 0000h-03FFh containing BASIC
0000                          ; 1K RAM from 0400h-0800h
0000                RAM_BASE:   EQU   0400h   
0000                RAM_TOP:   EQU   0800h   
0000                          ; Token values
0000                          ; 0-31 are variables (0 = @)
0000                          ; IntegerToken must be one more than last var
0000                INTEGERTOKEN:   EQU   32   
0000                QUESTIONMARKTOKEN:   EQU   33   
0000                STRINGTOKEN:   EQU   34   
0000                          ; Callable tokens are low byte of subroutine to call
0000                          ; Errors are displayed as Ex where x is an error
0000                          ; code which is tbe address on the stack when
0000                          ; Error subroutine is called.
0000                          ; Input buffer is just 8 bytes long
0000                          ; used by input statement to get an integer.
0000                          ; If there is a buffer overflow because user
0000                          ; enters too much, the behaviour is system
0000                          ; dependent - e.g. if writes above RAM
0000                          ; space do nothing then its not a problem.
0000                          ; If memory space repeats and lower 1K
0000                          ; is ROM then also not much of a problem.
0000                INPUT_BUFFER:   EQU   RAM_TOP-8   
0000                STACK_INIT:   EQU   RAM_TOP-8   
0000                          ; this must be on a 256 byte boundary
0000                VAR_SPACE:   EQU   RAM_BASE   
0000                          ; 30 words, first of which is not
0000                          ; accessible to user, so can be
0000                          ; used for PROG_PTR
0000                PROG_PTR:   EQU   RAM_BASE   
0000                          ; 2 words accessible to user as variables
0000                          ; 30 and 31 (^ and _)
0000                PROG_PARSE_PTR:   EQU   RAM_BASE+60   
0000                RNG_SEED:   EQU   RAM_BASE+62   
0000                PROG_BASE:   EQU   RAM_BASE+64   
0000                          .ORG   00h   
0000                          ; I would like this to be:
0000                          ; LXI H,PROG_BASE
0000                          ; SHLD PROG_PTR
0000                          ; JMP Ready
0000                          ; 
0000                          ; But this doesn't fit in 8 bytes.
0000                          ; Instead we find a place in the program
0000                          ; that already has "LXI B,PROG_BASE" and
0000                          ; follow it with "dw Ready" and set SP to that
0000                          ; address, then POP H from
0000                          ; the stack and store it in PROG_PTR, then
0000                          ; RET will jump to Ready.
0000                          ; We must ensure that Ready is at address
0000                          ; 00DE for this to work, because the
0000                          ; sequence DE00 executes SBI 0, which is
0000                          ; harmless.
0000   31 8C 02               LXI   SP,ExecuteProgram+1   
0003   E1                     POP   H   
0004   22 00 04               SHLD   PROG_PTR   
0007   C9                     RET   
0008                          .ORG   08h   
0008                          ; PutChar is called frequently
0008                          ; PutChar must return with Z set
0008                PUTCHAR:   
0008                          ; port 1 is for char I/O
0008   D3 01                  OUT   1   
000A                          ; 
000A                          ; Having the wait loop after the character
000A                          ; is output will slow down I/O when running
000A                          ; on hardware, but I can't think of a way
000A                          ; of fitting this into 8 bytes otherwise.
000A                          ; 
000A                PUTCHARWAITLOOP:   ; address 000ah
000A                          ; TODO change these few instructions
000A                          ; if targetting hardware
000A   AF                     XRA   A   
000B   C9                     RET   
000C                          ;IN 1
000C                          ;ANI 040h
000C                          ;RZ
000C                          ;db 0c3h ; opcode for JMP
000C                          ; the following two bytes are
000C                          ; 0ah and 00h, so this jumps to
000C                          ; PutCharWaitLoop
000C                          ; 
0010                          .ORG   10h   
0010   0A                     LDAX   B   ; opcode 0ah
0011   00                     NOP   ; opcode 00h
0012   03                     INX   B   
0013   E3                     XTHL   
0014   BE                     CMP   M   
0015   23                     INX   H   
0016   E3                     XTHL   
0017   C9                     RET   
0018                          ; 
0018                          .ORG   18h   
0018                          ; byte after RST is compared with A
0018                          ; if equal then jump to address on same page.
0018                          ; 
0018                          ; only use where performance is not
0018                          ; important (parsing, printing)
0018   E3                     XTHL   
0019   BE                     CMP   M   
001A   23                     INX   H   
001B   C3 21 00               JMP   CompareJump_Entry   
001E                          ; 
001E                          ; 2 bytes free
0020                          .ORG   20h   
0020   E3                     XTHL   
0021                COMPAREJUMP_ENTRY:   
0021   C2 25 00               JNZ   JZPage_Skip   
0024   6E                     MOV   L,M   
0025                JZPAGE_SKIP:   
0025   23                     INX   H   
0026                EXPAPPLYOP:   ; shared code
0026   E3                     XTHL   
0027   C9                     RET   
0028                          .ORG   28h   
0028                COMPAREHLDE:   
0028                          ; compare HL and DE, return
0028                          ; Z equal, NZ if not equal
0028                          ; C equal, NC if not equal
0028                          ; A will be zero if Z is set
0028   7D                     MOV   A,L   
0029   AB                     XRA   E   
002A   C0                     RNZ   
002B   7C                     MOV   A,H   
002C   AA                     XRA   D   
002D   C0                     RNZ   
002E   37                     STC   
002F   C9                     RET   
0030                          .ORG   30h   
0030                NEGATEDE:   
0030                          ;flags are not affected
0030                          ; 
0030                          ; decrement and invert so that we end
0030                          ; up with D in A - sometimes handy
0030   1B                     DCX   D   
0031   7B                     MOV   A,E   
0032   2F                     CMA   
0033   5F                     MOV   E,A   
0034   7A                     MOV   A,D   
0035   2F                     CMA   
0036   57                     MOV   D,A   
0037   C9                     RET   
0038                          .ORG   38h   
0038                          ; BC points to program
0038                          ; DE contains value
0038                          ; Stack is used for both operands and
0038                          ; operators
0038                EXPEVALUATE:   
0038                          ; This puts a marker on the stack to
0038                          ; detect when there are operators on the
0038                          ; stack - operators all have 2 as the hi byte
0038                          ; but this call puts hi byte 0 on the stack
0038   CD 3C 00               CALL   ExpEvaluateNum   
003B   C9                     RET   
003C                          ; ExpEvaluateNum must always be called
003C                          ; from page 0
003C                EXPEVALUATENUM:   
003C                          ; Expecting ( var integer or - sign
003C                          ; or function call
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
003C   D7 RST   2   
003D   AB                     DB   LeftBraceToken&0ffh   
        **MACRO UNROLL - RST_JZPAGE
003E   E7 RST   4   
003F   C1                     DB   (ExpLeftBrace&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0040   DF RST   3   
0041   DE 74                  DB   SubSub&0xff,(ExpNegate&0ffh)-1   
0043                          ; 
0043                          ; last function
0043   FE AF                  CPI   (RndSub+1)&0ffh   
0045   D4 D4 00               CNC   Error   
0048                          ; first function
0048   FE A8                  CPI   AbsSub&0ffh   
004A   D2 C3 00               JNC   FunctionCall   ; between RndSub and AbsSub
004D                          ; 
004D   FE 20                  CPI   IntegerToken   
004F   DA 59 00               JC   ExpVar   
0052                          ; 
0052                          ; Integer token is one more than last var
0052                          ; token so if carry is set then it is a var
0052                          ; 
0052   C4 D4 00               CNZ   Error   
0055                          ; Fall through to ExpInteger
0055                EXPINTEGER:   
0055   60                     MOV   H,B   
0056   69                     MOV   L,C   
0057   03                     INX   B   
0058   03                     INX   B   
0059                          ; 
0059                          ; fall through with carry clear
0059                EXPVAR:   
0059                          ; carry set if jumped to here
0059                          ; 
0059   DC AB 00               CC   GetVarLocation   
005C                EXPVARGETVALUE:   
005C   5E                     MOV   E,M   
005D   23                     INX   H   
005E   56                     MOV   D,M   
005F                EXPEVALUATEOP:   
005F                          ;Expecting operator or right bracket or
005F                          ;end of expression
005F                          ; 
005F                          ;Are there operators on the stack?
005F   E1                     POP   H   
0060                          ; 
0060                          ; H will be 0 if no operators on
0060                          ; stack (i.e. high byte of return address)
0060                          ; 
0060   7C                     MOV   A,H   
        **MACRO UNROLL - RST_COMPAREJUMP
0061   DF RST   3   
0062   00 6D                  DB   0,(SkipExpApplyOp&0ffh)-1   
0064                          ; 
0064                          ; if L is equal to MulSub then apply it.
0064                          ; this gives * same precedence as /
0064   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
0065   DF RST   3   
0066   E2 25                  DB   (MulSub&0ffh),(ExpApplyOp&0ffh)-1   
0068                          ; 
0068   0A                     LDAX   B   
0069                          ; 
0069                          ; No longer needed since case below
0069                          ; includes this
0069                          ;CPI Operators&0ffh
0069                          ; Is it the end of the expression?
0069                          ;JC ExpApplyOp
0069                          ; 
0069                          ; Does operator on stack have GTE precedence?
0069                          ; (or end of expression, when A < operators)
0069   3D                     DCR   A   
006A   BD                     CMP   L   
006B                          ; 
006B   DA 26 00               JC   ExpApplyOp   ; apply the operator
006E                          ; that was on the stack
006E                          ; 
006E                SKIPEXPAPPLYOP:   
006E   E5                     PUSH   H   ; put operator that was on stack
006F                          ; back onto stack
006F                          ; 
006F   0A                     LDAX   B   
0070                          ; 
0070   FE C5                  CPI   Operators&0ffh   
0072                          ; Is it the end of the expression?
0072   D8                     RC   
0073                          ; 
0073   03                     INX   B   
0074                          ; 
0074                          ; Code shared with ExpNegate
0074                          ; so use a CPI to eat the initial
0074                          ; LXI in ExpNegate
0074                          ; 
0074   FE                     DB   0feh   ; OpCode for CPI to mop up LXI
0075                EXPNEGATE:   
0075                          ; Put 0 onto stack and - onto
0075                          ; operator stack
0075   11 00 00               LXI   D,0   
0078                          ; 
0078   21 5F 00               LXI   H,ExpEvaluateOp   ; address to return to
007B                          ; after operator is called
007B   E5                     PUSH   H   
007C                          ; 
007C   D5                     PUSH   D   ; operand
007D   6F                     MOV   L,A   ; operator address
007E   26 02                  MVI   H,PrintSub/256   
0080   E5                     PUSH   H   
0081                          ; 
0081   C3 3C 00               JMP   ExpEvaluateNum   
0084                          ; 
0084                PRINTSUBLOOP:   
0084                PRINTSUBIMPL:   
0084                          ; on call HL is address of PrintSub
0084                          ; so H has odd parity
0084                          ; on subsequent passes H = 0 or QuoteChar
0084                          ; so H has even parity
0084   0A                     LDAX   B   
0085                          ; 
0085   D6 22                  SUI   StringToken   
        **MACRO UNROLL - RST_JZPAGE
0087   E7 RST   4   
0088   93                     DB   (PrintSubString&0ffh)-1   
0089                          ; 
0089                          ; This assumes that LinenumSub is the
0089                          ; next token after StringToken
0089   FE 81                  CPI   (LastStatement-StringToken+1)&0ffh   
008B                          ; 
008B   24                     INR   H   ; doesn't affect carry
008C                          ; parity will be even if we've just
008C                          ; entered subroutine.
008C                          ; odd otherwise
008C                          ; 
008C   DA 9E 00               JC   PrintSubEnd   
008F                          ; 
008F                PRINTSUBEXPRESSION:   
        **MACRO UNROLL - RST_EXPEVALUATE
008F   FF RST   7   
0090   CD 8D 01               CALL   PrintInteger   
0093                          ; 
0093   11                     DB   11h   ; opcode for LXI D eats 2 bytes
0094                          ; 3rd byte is NOP
0094                PRINTSUBSTRING:   
0094   CD BA 00               CALL   OutputString   ; carry is clear on return
0097                          ; A is either Quote char or zero at this point
0097                          ; (00000000 or 00100010) both even parity
0097   67                     MOV   H,A   
0098                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
0098   D7 RST   2   
0099   A6                     DB   CommaToken   
        **MACRO UNROLL - RST_JZPAGE
009A   E7 RST   4   
009B   83                     DB   (PrintSubLoop&0ffh)-1   
009C                          ; 
009C   0B                     DCX   B   
009D   25                     DCR   H   ; make sure that newline is printed when
009E                          ; we fall through, parity will be even
009E                PRINTSUBEND:   
009E   E0                     RPO   ; don't print newline if we've just had
009F                          ; comma
009F                CRLF:     
009F   3E 0D                  MVI   A,13   
        **MACRO UNROLL - RST_PUTCHAR
00A1   CF RST   1   
00A2   3E 0A                  MVI   A,10   
        **MACRO UNROLL - RST_PUTCHAR
00A4   CF RST   1   
00A5   C9                     RET   
00A6                GETVARLOCATIONBVAR:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00A6   D7 RST   2   
00A7                          ; Test that we have a var
00A7   20                     DB   32   
00A8   D4 D4 00               CNC   Error   
00AB                GETVARLOCATION:   
00AB                          ; A should contain a var token
00AB                          ; and B points to tbe location after
00AB                          ; the var token
00AB                          ; return with var address in HL
00AB                          ; and B pointing to next char
00AB                          ; A will never be 255 on return
00AB   26 04                  MVI   H,VAR_SPACE/256   
00AD   87                     ADD   A   
00AE   6F                     MOV   L,A   
00AF                          ; 
00AF   C0                     RNZ   
00B0                          ; 
00B0                          ; fall through if it is array var
00B0                          ; 
00B0   CD CB 00               CALL   ExpBracketedB   
00B3                          ; 
00B3                          ; Now DE contains the array index
00B3                          ; Add it twice to get the offset
00B3                          ; 
00B3   2A 3C 04               LHLD   PROG_PARSE_PTR   
00B6   23                     INX   H   ; up 1 byte to avoid EndProgram marker
00B7   19                     DAD   D   
00B8   19                     DAD   D   
00B9                OUTPUTSTRINGRET:   ; shared code, nearest RET
00B9   C9                     RET   
00BA                          ; This 9 byte routine can be moved anywhere to
00BA                          ; fill holes
00BA                OUTPUTSTRING:   
00BA                          ;Pointer in B points to string token marker
00BA   03                     INX   B   
00BB                OUTPUTSTRINGLOOP:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00BB   D7 RST   2   
00BC   22                     DB   StringToken   
        **MACRO UNROLL - RST_JZPAGE
00BD   E7 RST   4   
00BE   B8                     DB   (OutputStringRet&0ffh)-1   
00BF                OUTPUTSTRING_WITHQUOTE:   
        **MACRO UNROLL - RST_PUTCHAR
00BF   CF RST   1   
        **MACRO UNROLL - RST_JZPAGE
00C0   E7 RST   4   
00C1   BA                     DB   (OutputStringLoop&0ffh)-1   
00C2                EXPLEFTBRACE:   
00C2   0B                     DCX   B   
00C3                FUNCTIONCALL:   
00C3                          ; push return address
00C3   11 5F 00               LXI   D,ExpEvaluateOp   
00C6   D5                     PUSH   D   
00C7                          ; A contains the address to call on page 2
00C7                          ; push function address
00C7   6F                     MOV   L,A   
00C8   26 02                  MVI   H,PrintSub/256   
00CA   E5                     PUSH   H   
00CB                          ; 
00CB                          ; fall through
00CB                          ; This must be before Error so that it
00CB                          ; can fall through
00CB                EXPBRACKETEDB:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00CB   D7 RST   2   
00CC   AB                     DB   LeftBraceToken&0ffh   
00CD   C4 D4 00               CNZ   Error   
        **MACRO UNROLL - RST_EXPEVALUATE
00D0   FF RST   7   
00D1                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00D1   D7 RST   2   
00D2   A5                     DB   RightBraceToken&0ffh   
00D3   C8                     RZ   
00D4                          ; 
00D4                          ; fall through
00D4                          ;Display error code and go back to line entry
00D4                ERROR:    
00D4   CD 9F 00               CALL   CRLF   
00D7   3E 45                  MVI   A,'E'   
        **MACRO UNROLL - RST_PUTCHAR
00D9   CF RST   1   
00DA   D1                     POP   D   
00DB   CD 8D 01               CALL   PrintInteger   
00DE                          ; 
00DE                          ; fall through
00DE                          ; 
00DE                          ; we need ready to be at 00DE
00DE                          .ORG   00deh   
00DE                READY:    
00DE                          ; Set stack pointer
00DE                          ; Do this every time to guard against
00DE                          ; GOSUB with no RETURN errors
00DE                          ; 
00DE   31 F8 07               LXI   SP,STACK_INIT   
00E1                          ; 
00E1   CD 9F 00               CALL   CRLF   
00E4                          ; 
00E4                          ; Use this if no CRLF is needed
00E4                          ; and sure that stack can't be wrong
00E4                READYNONEWLINE:   
00E4                          ; 
00E4   2A 00 04               LHLD   PROG_PTR   
00E7   E5                     PUSH   H   ; push it because we need it after
00E8                          ; GetLine
00E8   CD 22 03               CALL   GetLine   
00EB                          ; 
00EB   36 87                  MVI   M,EndProgram&0ffh   
00ED                          ; 
00ED   22 3C 04               SHLD   PROG_PARSE_PTR   
00F0   E1                     POP   H   
00F1                          ; 
00F1   E5                     PUSH   H   
00F2   C1                     POP   B   
00F3                          ; 
00F3   7E                     MOV   A,M   
00F4                          ; Regardless of which branch taken
00F4                          ; we need this marker here.
00F4                          ; This overwrites the token to execute,
00F4                          ; but we've already got that in A
00F4   36 87                  MVI   M,EndProgram&0ffh   
00F6                          ; 
00F6   FE 20                  CPI   IntegerToken   
00F8   C2 91 02               JNZ   ExecuteDirect   
00FB                          ; 
00FB                LINESTARTSWITHINT:   
00FB                          ; Get the line number into DE
00FB   23                     INX   H   
00FC   5E                     MOV   E,M   
00FD   23                     INX   H   
00FE   56                     MOV   D,M   
00FF   23                     INX   H   
0100                          ; 
0100                          ; Is it an integer all by itself?
0100                          ; If so then delete the line
0100                          ; 
0100                          ; call GetLineNum to find either the line, or
0100                          ; pointer to next location in program after it
0100                          ; 
0100   66                     MOV   H,M   ; preserve M (GetLineNum doesn't touch H)
0101   CD B5 03               CALL   GetLineNum   
0104   7C                     MOV   A,H   
0105   2A 00 04               LHLD   PROG_PTR   
0108   F5                     PUSH   PSW   
0109                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
0109   DF RST   3   
010A   87                     DB   EndProgram&0ffh   
010B   1B                     DB   (DeleteProgramLine&0ffh)-1   
010C                          ; 
010C   F1                     POP   PSW   
010D                          ; if GetLineNum returns a match then this is
010D                          ; an error, user must delete line first
010D   CC D4 00               CZ   Error   
0110                          ; 
0110                          ; do a memory rotate with
0110                          ; first = GetLine/ATNLN address
0110                          ; middle = PROG_PTR
0110                          ; last = PROG_PARSE_PTR
0110                          ; 
0110   36 28                  MVI   M,LineNumSub&0ffh   ; undo what we did earlier
0112   EB                     XCHG   
0113   2A 3C 04               LHLD   PROG_PARSE_PTR   
0116                          ; 
0116   E5                     PUSH   H   ; last
0117   C5                     PUSH   B   ; first
0118                          ; 
0118   D5                     PUSH   D   ; middle
0119                          ; 
0119   AF                     XRA   A   
011A                          ; 
        **MACRO UNROLL - RST_JZPAGE
011A   E7 RST   4   
011B   2B                     DB   (Entry&0ffh)-1   
011C                DELETEPROGRAMLINE:   
011C                          ; 25 bytes
011C   F1                     POP   PSW   
011D                          ; 
011D   C2 E4 00               JNZ   ReadyNoNewLine   ; line not found, do nothing
0120   E5                     PUSH   H   
0121   C5                     PUSH   B   ; first
0122   E5                     PUSH   H   ; last
0123                          ; 
0123   09                     DAD   B   ; HL=PROG_PTR+first
0124                          ; 
0124   03                     INX   B   
0125   CD D0 03               CALL   ATNLN_Int   ; Z is set when this is called
0128                          ; 
0128                          ;set HL to what we want PROG_PTR to be
0128   50                     MOV   D,B   
0129   59                     MOV   E,C   
        **MACRO UNROLL - RST_NEGATEDE
012A   F7 RST   6   
012B                          ; 
012B   19                     DAD   D   ; HL=PROG_PTR+first-middle
012C                          ; 
012C                          ; because DAD D above always causes HL
012C                          ; to decrease, it must set carry
012C                          ; so STC below is not needed
012C                          ;STC ; skip first reverse in memory rotate
012C                          ; because we don't care about the
012C                          ; line being deleted
012C                          ; 
012C                ENTRY:    
012C                          ; carry is clear if coming from insert
012C                          ; 
012C   C5                     PUSH   B   ; middle (or first)
012D   22 00 04               SHLD   PROG_PTR   
0130                          ; 
0130                MEMORYROTATE:   
0130                          ; 27 bytes
0130                          ; stack must contain (from top down)
0130                          ; first, middle, first, last
0130                          ; DE = middle
0130                          ; HL = Last
0130   D4 3D 01               CNC   Reverse   
0133   CD 3A 01               CALL   ReverseDH   
0136   01 E4 00               LXI   B,ReadyNoNewLine   
0139   C5                     PUSH   B   
013A                REVERSEDH:   
013A   E1                     POP   H   
013B   D1                     POP   D   
013C   E3                     XTHL   
013D                REVERSE:   
013D                          ; HL = last (i.e 1 after the last byte to swap)
013D                          ; DE = first
013D                REVERSELOOP:   
        **MACRO UNROLL - RST_COMPAREHLDE
013D   EF RST   5   
013E   C8                     RZ   
013F   2B                     DCX   H   
        **MACRO UNROLL - RST_COMPAREHLDE
0140   EF RST   5   
0141   C8                     RZ   
0142                          ; 
0142   46                     MOV   B,M   
0143   1A                     LDAX   D   
0144   77                     MOV   M,A   
0145   78                     MOV   A,B   
0146   12                     STAX   D   
0147   13                     INX   D   
0148                          ; 
0148   C3 3D 01               JMP   ReverseLoop   
014B                POPHASSIGNTOVAR_PREFIX:   
014B   E5                     PUSH   H   
014C                          ; 
014C   CD 25 03               CALL   GetLineNoPrompt   
014F   C1                     POP   B   
        **MACRO UNROLL - RST_EXPEVALUATE
0150   FF RST   7   
0151   C1                     POP   B   
0152                          ; fall through
0152                POPHASSIGNTOVAR:   
0152   E1                     POP   H   
0153                          ; 
0153                          ; Put DE into var (HL)
0153                          ; 
0153   73                     MOV   M,E   
0154   23                     INX   H   
0155   72                     MOV   M,D   
0156                          ; 
0156   C9                     RET   
0157                LISTLOOP:   
0157   3E 20                  MVI   A,' '   
        **MACRO UNROLL - RST_PUTCHAR
0159   CF RST   1   
015A                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
015A   D7 RST   2   
015B   87                     DB   EndProgram&0ffh   
015C   C8                     RZ   
015D                          ; 
015D   21 57 01               LXI   H,ListLoop   ; so that we can loop using RET
0160   E5                     PUSH   H   
0161                          ; H is already set to the correct page
0161   2E B4                  MVI   L,(TokenList-1)&0ffh   
0163                          ; These need to be on same page
0163                          ; currently on page 3
        **MACRO UNROLL - RST_COMPAREJUMP
0163   DF RST   3   
0164   22 AC                  DB   StringToken,(List_String&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0166   DF RST   3   
0167   28 83                  DB   LinenumSub&0ffh,(List_Linenum&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0169   DF RST   3   
016A   20 86                  DB   IntegerToken,(List_Integer&0ffh)-1   
016C   DA B1 01               JC   List_Var   
016F                          ; No need to check for end of TokenList
016F                          ; impossible not to be a token value in A
016F                LIST_TOKEN_LOOP:   
016F   56                     MOV   D,M   
0170   14                     INR   D   
0171   23                     INX   H   
0172   F2 6F 01               JP   List_Token_Loop   
0175                LIST_TOKEN:   
0175                          ; on entry, A contains the token
0175                          ; so must not use A during this loop
0175   BE                     CMP   M   
0176   23                     INX   H   
0177   C2 6F 01               JNZ   List_Token_Loop   
017A                          ; 
017A                LIST_TOKEN_STRING_LOOP:   
017A   7E                     MOV   A,M   
017B   E6 7F                  ANI   07fh   
        **MACRO UNROLL - RST_PUTCHAR
017D   CF RST   1   
017E   B6                     ORA   M   
017F   23                     INX   H   
0180   F2 7A 01               JP   List_Token_String_Loop   
0183   C9                     RET   
0184                          ; 
0184                LIST_LINENUM:   
0184   CD 9F 00               CALL   CRLF   
0187                LIST_INTEGER:   
0187   0A                     LDAX   B   
0188   03                     INX   B   
0189   5F                     MOV   E,A   
018A   0A                     LDAX   B   
018B   03                     INX   B   
018C   57                     MOV   D,A   
018D                          ; fall through to PrintInteger
018D                          ; 
018D                          ;Output the value in DE
018D                PRINTINTEGER:   
018D   AF                     XRA   A   
018E   F5                     PUSH   PSW   ; end marker is Z flag
018F                          ; 
018F   B2                     ORA   D   ; S is set if -ve
        **MACRO UNROLL - RST_NEGATEDE
0190   F7 RST   6   
0191                          ; 
0191   F2 98 01               JP   PrintIntegerLoop   
0194   3E 2D                  MVI   A,'-'   
        **MACRO UNROLL - RST_PUTCHAR
0196   CF RST   1   
        **MACRO UNROLL - RST_NEGATEDE
0197   F7 RST   6   
0198                          ; 
0198                PRINTINTEGERLOOP:   
0198                          ; need HL to be -ve here, so that it can
0198                          ; handle -32768
0198                          ; 
0198   EB                     XCHG   
0199   11 0A 00               LXI   D,10   
019C                          ; 
019C   CD F6 02               CALL   DivideHL   
019F                          ; HL contains remainder after / 10
019F                          ; DE contains the quotient
019F   3E 30                  MVI   A,'0'   
01A1   95                     SUB   L   
01A2   F5                     PUSH   PSW   ; push onto stack
01A3                          ; 
01A3                          ; if DE is zero we are done
01A3   7A                     MOV   A,D   
01A4   B3                     ORA   E   
01A5   C2 98 01               JNZ   PrintIntegerLoop   
01A8                          ; 
01A8                PRINTINTEGERLOOP2:   
01A8   F1                     POP   PSW   
01A9   C8                     RZ   ; Z is set on return, HL<=0
        **MACRO UNROLL - RST_PUTCHAR
01AA   CF RST   1   
        **MACRO UNROLL - RST_JZPAGE
01AB   E7 RST   4   
01AC   A7                     DB   (PrintIntegerLoop2&0ffh)-1   
01AD                LIST_STRING:   
01AD   CD BF 00               CALL   OutputString_WithQuote   
01B0   11                     DB   011h   ; LXI D skips 2 bytes
01B1                LIST_VAR:   
01B1   C6 40                  ADI   '@'   
        **MACRO UNROLL - RST_PUTCHAR
01B3   CF RST   1   
01B4   C9                     RET   ; byte before TokenList must have high bit set
01B5                          ; Index to subroutine address must not overlap with other tokens
01B5                          ; Currently TokenList starts toward the end
01B5                          ; of page 1, and DivSub begins towards the end
01B5                          ; of page 2 and the subroutine extends into page 3
01B5                          ; order in this list must make sure that a
01B5                          ; token A that is a left substring of another
01B5                          ; token B appears later in the list than B
01B5                          ; e.g. < is after <=
01B5                          ; 
01B5                TOKENLIST:   
01B5   21                     DB   QuestionMarkToken&0ffh   
01B6   BF                     DB   '?'+128   
01B7   2B                     DB   PrintSub&0ffh   
01B8   50 52 49 4E D4         DB   "PRIN",'T'+128   
01BD   54                     DB   LetSub&0ffh   
01BE   4C 45 D4               DB   "LE",'T'+128   
01C1   33                     DB   GotoSub&0ffh   
01C2   47 4F 54 CF            DB   "GOT",'O'+128   
01C6   2E                     DB   GosubSub&0ffh   
01C7   47 4F 53 55 C2         DB   "GOSU",'B'+128   
01CC   3B                     DB   ReturnSub&0ffh   
01CD   52 45 54 55 52 CE      DB   "RETUR",'N'+128   
01D3   45                     DB   InputSub&0ffh   
01D4   49 4E 50 55 D4         DB   "INPU",'T'+128   
01D9   50                     DB   ForSub&0ffh   
01DA   46 4F D2               DB   "FO",'R'+128   
01DD   61                     DB   NextSub&0ffh   
01DE   4E 45 58 D4            DB   "NEX",'T'+128   
01E2   81                     DB   IfSub&0ffh   
01E3   49 C6                  DB   "I",'F'+128   
01E5   88                     DB   EndSub&0ffh   
01E6   45 4E C4               DB   "EN",'D'+128   
01E9                          ; 
01E9                          ; Before this are keywords allowed at run-time
01E9   8B                     DB   ExecuteProgram&0ffh   
01EA   52 55 CE               DB   "RU",'N'+128   
01ED   A2                     DB   ListSub&0ffh   
01EE   4C 49 53 D4            DB   "LIS",'T'+128   
01F2   A1                     DB   NewSub&0ffh   
01F3   4E 45 D7               DB   "NE",'W'+128   
01F6                          ; 
01F6                          ; 
01F6                          ; 
01F6                          ; before operators are non-statement
01F6                          ; non-operator tokens
01F6   A8                     DB   AbsSub&0ffh   
01F7   41 42 D3               DB   "AB",'S'+128   
01FA   AC                     DB   UsrSub&0ffh   
01FB   55 53 D2               DB   "US",'R'+128   
01FE   AE                     DB   RndSub&0ffh   
01FF   52 4E C4               DB   "RN",'D'+128   
0202                          ; 
0202   A3                     DB   ToToken&0ffh   
0203   54 CF                  DB   "T",'O'+128   
0205   A4                     DB   StepToken&0ffh   
0206   53 54 45 D0            DB   "STE",'P'+128   
020A   A6                     DB   CommaToken   
020B   AC                     DB   ","+128   
020C   AB                     DB   LeftBraceToken&0ffh   
020D   A8                     DB   '('+128   
020E   A5                     DB   RightBraceToken&0ffh   
020F   A9                     DB   ')'+128   
0210   D3                     DB   EqualSub&0ffh   
0211   BD                     DB   '='+128   
0212   D6                     DB   NotEqualSub&0ffh   
0213   3C BE                  DB   "<",'>'+128   
0215   C6                     DB   GTESub&0ffh   
0216   3E BD                  DB   ">",'='+128   
0218   C5                     DB   LTESub&0ffh   
0219   3C BD                  DB   "<",'='+128   
021B   CA                     DB   LTSub&0ffh   
021C   BC                     DB   '<'+128   
021D   C9                     DB   GTSub&0ffh   
021E   BE                     DB   '>'+128   
021F   DD                     DB   AddSub&0ffh   
0220   AB                     DB   '+'+128   
0221   DE                     DB   SubSub&0ffh   
0222   AD                     DB   '-'+128   
0223   E2                     DB   MulSub&0ffh   
0224   AA                     DB   '*'+128   
0225   F6                     DB   DivSub&0ffh   
0226   AF                     DB   '/'+128   
0227   FF                     DB   255   ; 255 can only occur at the end
0228                          ; 
0228                LINENUMSUB:   
0228   03                     INX   B   
0229   03                     INX   B   
022A   C9                     RET   
022B                          ; 
022B                PRINTSUB:   
022B   C3 84 00               JMP   PrintSubImpl   
022E                          ; 
022E                GOSUBSUB:   
        **MACRO UNROLL - RST_EXPEVALUATE
022E   FF RST   7   
022F   E1                     POP   H   
0230                          ; 
0230   C5                     PUSH   B   
0231   E5                     PUSH   H   
0232                          ; 
0232   3E                     DB   03eh   ; opcode for MVI A to eat next byte
0233                GOTOSUB:   
        **MACRO UNROLL - RST_EXPEVALUATE
0233   FF RST   7   
0234   CD B5 03               CALL   GetLineNum   
0237   C8                     RZ   
0238   CD D4 00               CALL   Error   
023B                RETURNSUB:   
023B                          ; Expect stack size to be 6 or more
023B                          ; any less and we have return without gosub
023B   21 0D F8               LXI   H,-(STACK_INIT-6)-1   
023E   39                     DAD   SP   
023F   DC D4 00               CC   Error   
0242                          ; 
0242   E1                     POP   H   ; Get return address first
0243   C1                     POP   B   ; Get pointer to program loc to return to
0244   E9                     PCHL   ; instead of RET
0245                INPUTSUB:   
0245   CD A6 00               CALL   GetVarLocationBVar   
0248   E5                     PUSH   H   
0249   21 F8 07               LXI   H,INPUT_BUFFER   
024C   C5                     PUSH   B   
024D                          ; 
024D   C3 4B 01               JMP   POPHAssignToVar_Prefix   
0250                FORSUB:   
0250   21 E3 03               LXI   H,ForSubImpl   
0253   E5                     PUSH   H   
0254                          ; fall through to LetSub
0254                          ; First part is just like let statement
0254                LETSUB:   
0254   CD A6 00               CALL   GetVarLocationBVar   
0257   E5                     PUSH   H   
0258                          ; 
0258                          ; Test that we have an equals sign
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
0258   D7 RST   2   
0259                          ; 
0259   D3                     DB   EqualSub&0ffh   
025A   C4 D4 00               CNZ   Error   
025D                          ; 
        **MACRO UNROLL - RST_EXPEVALUATE
025D   FF RST   7   
025E                          ; 
025E   C3 52 01               JMP   POPHAssignToVar   
0261                          ; 
0261                NEXTSUB:   
0261   E1                     POP   H   ; discard return address
0262                          ; stack contains <SP> VL+1,S,-T,LS,EPL
0262   E1                     POP   H   ; get VL+1
0263                          ; stack contains VL+1 <SP> S,-T,LS,EPL
0263   56                     MOV   D,M   
0264   2B                     DCX   H   
0265   5E                     MOV   E,M   
0266                          ; 
0266   E3                     XTHL   ; step is in HL, VL is in (SP)
0267                          ; stack contains VL+1 <SP> VL, -T,LS,EPL
0267   EB                     XCHG   ; step is in DE, var value in HL
0268   19                     DAD   D   ; add step onto var
0269   EB                     XCHG   ; result is in DE, step is in HL
026A   E3                     XTHL   ; step is in (SP), VL is in HL
026B                          ; stack contains VL+1 <SP> S, -T,LS,EPL
026B                          ; 
026B   73                     MOV   M,E   ; put back into VL
026C   23                     INX   H   ; H = VL+1
026D   72                     MOV   M,D   ; DE now has loop var value (LV)
026E                          ; 
026E   F1                     POP   PSW   ; get step so that hi bit of A has
026F                          ; sign of step
026F   E1                     POP   H   ; get -T
0270                          ; stack contains VL+1,S,-T <SP> LS,EPL
0270                          ; 
0270   19                     DAD   D   ; HL now has LV-T
0271                          ; 
0271   AC                     XRA   H   ; xor sign of step with
0272                          ; sign of result
0272                          ; 
0272                          ; if result of xor above is 1
0272                          ; then keep looping, or if HL
0272                          ; is zero then keep looping
0272                          ; 
0272   D1                     POP   D   ; this is LoopStart
0273                          ; stack contains VL+1,S,-T,LS <SP> EPL
0273                          ; 
0273   FA 79 02               JM   NextSubLoop   
0276                          ; 
0276   7C                     MOV   A,H   
0277   B5                     ORA   L   
0278   C0                     RNZ   
0279                          ; 
0279                NEXTSUBLOOP:   
0279                          ; 
0279   42                     MOV   B,D   
027A   4B                     MOV   C,E   
027B   21 F6 FF               LXI   H,-10   
027E   39                     DAD   SP   
027F   F9                     SPHL   
0280                          ; 
0280   C9                     RET   
0281                          ; 
0281                IFSUB:    
        **MACRO UNROLL - RST_EXPEVALUATE
0281   FF RST   7   
0282   7A                     MOV   A,D   
0283   B3                     ORA   E   
0284   C0                     RNZ   
0285                          ; If DE zero then fall through to next line
0285   C3 D2 03               JMP   AdvanceToNextLineNum   
0288                ENDSUB:   
0288   C3 DE 00               JMP   Ready   
028B                          ; Hi byte of AdvanceToNextLineNum is 3
028B                          ; which is opcode for INR B : harmless
028B                ENDPROGRAM:   EQU   EndSub-1   
028B                EXECUTEPROGRAM:   
028B                          ; Point BC to first line
028B                          ; Don't skip over the line number
028B                          ; because we need the constant PROG_BASE
028B                          ; at this location in memory
028B   01 40 04               LXI   B,PROG_BASE   
028E   DE 00                  DW   Ready   ; Ready must correspond to
0290                          ; a hatmless instruction sequence
0290                EXECUTEPROGRAMLOOP:   
0290   0A                     LDAX   B   
0291                          ; 
0291                EXECUTEDIRECT:   
0291                          ; 
0291   D6 28                  SUI   LineNumSub&0ffh   
0293                          ; 
0293                          ; Check that it is a token between
0293                          ; LinenumSub and LastStatement
0293   FE 7B                  CPI   (LastStatement-LineNumSub+1)&0ffh   
0295   D4 D4 00               CNC   Error   
0298                          ; 
0298   03                     INX   B   
0299   C6 28                  ADI   LineNumSub&0ffh   
029B                          ; 
029B                          ; Carry is clear now
029B                          ; 
029B                          ; Put return address onto stack
029B   21 90 02               LXI   H,ExecuteProgramLoop   
029E   E5                     PUSH   H   
029F                          ; 
029F                          ; Put pointer to call address into HL
029F   6F                     MOV   L,A   
02A0                          ; ExecuteProgramLoop must be on the same page
02A0                          ; page as PrintSub so that we don't have to
02A0                          ; update H
02A0                          ; Jump to it
02A0                          ; Carry is clear when we do this
02A0   E9                     PCHL   
02A1                NEWSUB:   
02A1   C7                     RST   0   
02A2                LASTSTATEMENT:   
02A2                LISTSUB:   
02A2   01 40 04               LXI   B,PROG_BASE   
02A5   C3 57 01               JMP   ListLoop   
02A8                          ; 
02A8                          ; ( ) , TO STEP tokens must have values between
02A8                          ; statements and functions
02A8                TOTOKEN:   EQU   ListSub+1   
02A8                STEPTOKEN:   EQU   ListSub+2   
02A8                RIGHTBRACETOKEN:   EQU   ListSub+3   
02A8                COMMATOKEN:   EQU   ListSub+4   
02A8                ABSSUB:   
02A8                          ; A = right brace token, which has high bit
02A8                          ; set, so no need to negate DE if XRA with D
02A8                          ; still leaves high bit set
02A8   AA                     XRA   D   
02A9   F8                     RM   
        **MACRO UNROLL - RST_NEGATEDE
02AA   F7 RST   6   
02AB                          ; 
02AB                          ; shared code. okay for this to go here
02AB                          ; because in ExpEvaluateNum, test for
02AB                          ; left brace is before test for token
02AB                          ; between first and last function
02AB                LEFTBRACETOKEN:   
02AB   C9                     RET   
02AC                          ; 
02AC                USRSUB:   
02AC   EB                     XCHG   
02AD   E9                     PCHL   
02AE                RNDSUB:   
02AE                          ; LCG
02AE                          ; don't use low byte in return value.
02AE                          ; Multiplier 47989 is mentioned here:
02AE                          ; https://groups.google.com/g/prng/c/evszGs76o1w?pli=1
02AE   D5                     PUSH   D   
02AF   2A 3E 04               LHLD   RNG_SEED   
02B2   11 75 BB               LXI   D,47989   
02B5   CD E2 02               CALL   MulSub   ; A is zero after this
02B8   EB                     XCHG   
02B9   23                     INX   H   
02BA   22 3E 04               SHLD   RNG_SEED   
02BD                          ; Use only the high byte to get a value
02BD                          ; between 0 and 255
02BD   6C                     MOV   L,H   
02BE   67                     MOV   H,A   
02BF   D1                     POP   D   
02C0                          ; 
02C0   CD F6 02               CALL   DivideHL   
02C3   EB                     XCHG   
02C4   C9                     RET   
02C5                          ; XORSHIFT taken from here
02C5                          ; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
02C5                          ;LHLD RNG_SEED
02C5                          ;MOV A,H
02C5                          ;RAR
02C5                          ;MOV A,L
02C5                          ;RAR
02C5                          ;XRA H
02C5                          ;MOV H,A
02C5                          ;MOV A,L
02C5                          ;RAR
02C5                          ;MOV A,H
02C5                          ;RAR
02C5                          ;XRA L
02C5                          ;MOV L,A
02C5                          ;XRA H ; clears carry
02C5                          ;MOV H,A
02C5                          ;SHLD RNG_SEED
02C5                          ; carry is clear at this point
02C5                          ;RAR
02C5                          ;MOV H,A
02C5                          ; above 2 bytes give us a value between
02C5                          ; 0 and 32767
02C5                          ;CALL DivideHL
02C5                          ;XCHG
02C5                          ;RET
02C5                          ; Token values >= this are all operators
02C5                OPERATORS:   
02C5                          ; 
02C5                LTESUB:   
02C5                          ; Swap operands and fall through
02C5   EB                     XCHG   
02C6                GTESUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02C6   EF RST   5   
        **MACRO UNROLL - RST_JZPAGE
02C7   E7 RST   4   
02C8   D3                     DB   (BinReturn&0ffh)-1   
02C9                GTSUB:    
02C9                          ; Swap operands and fall through
02C9   EB                     XCHG   
02CA                LTSUB:    
02CA   7D                     MOV   A,L   
02CB   93                     SUB   E   
02CC   7C                     MOV   A,H   
02CD   9A                     SBB   D   
02CE   1F                     RAR   
02CF   AC                     XRA   H   
02D0   AA                     XRA   D   
02D1   17                     RAL   
02D2   3E                     DB   3eh   ; MVI A opcode to eat next byte
02D3                EQUALSUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02D3   EF RST   5   ; returns Z iff HL=DE
02D4                BINRETURN:   
02D4   3F                     CMC   
02D5   3E                     DB   3eh   ; MVI A opcode to swallow next byte
02D6                          ; 
02D6                NOTEQUALSUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02D6   EF RST   5   ; returns Z iff HL=DE
02D7   11 01 00               LXI   D,1   
02DA   D0                     RNC   
02DB   1B                     DCX   D   
02DC   C9                     RET   
02DD                ADDSUB:   
02DD   3E                     DB   3eh   ; opcode for MVI A, to eat next byte
02DE                SUBSUB:   
        **MACRO UNROLL - RST_NEGATEDE
02DE   F7 RST   6   
02DF                          ;Add DE to HL and keep in DE
02DF   19                     DAD   D   
02E0   EB                     XCHG   
02E1                          ; 
02E1   C9                     RET   
02E2                MULSUB:   
02E2                          ; 20 bytes
02E2                          ; multiple HL and DE into DE, preserving B
02E2   C5                     PUSH   B   
02E3   44                     MOV   B,H   
02E4   4D                     MOV   C,L   
02E5                MULTIPLY:   
02E5                          ;multiply BC and DE into DE
02E5   3E 10                  MVI   A,16   
02E7                MULLOOP:   
02E7   29                     DAD   H   
02E8   EB                     XCHG   
02E9   29                     DAD   H   
02EA   EB                     XCHG   
02EB   D2 EF 02               JNC   DontAdd   
02EE   09                     DAD   B   
02EF                DONTADD:   
02EF   3D                     DCR   A   
02F0   C2 E7 02               JNZ   MulLoop   
02F3                          ; 
02F3   EB                     XCHG   
02F4   C1                     POP   B   
02F5   C9                     RET   
02F6                          ; 
02F6                DIVSUB:   
02F6                          ; 31 bytes
02F6                          ;Divide HL by DE
02F6                          ;Remainder in HL
02F6                          ;Result in DE
02F6                DIVIDEHL:   
02F6                          ;Divide HL by DE
02F6                          ; Make HL and DE different signs
02F6   7C                     MOV   A,H   
02F7   CD A8 02               CALL   AbsSub   
02FA   F5                     PUSH   PSW   
02FB                          ; 
02FB                          ;Divide HL by DE
02FB                          ;Assuming that HL and DE are different signs
02FB   C5                     PUSH   B   
02FC   01 FF FF               LXI   B,0ffffh   
02FF                          ; 
02FF                          ; Do the test for zero here because we want the
02FF                          ; CZ to be on page 3
02FF                          ; This means that divide by zero and unterminated
02FF                          ; string both have tbe same error code, but kt
02FF                          ; will be obvious to the programmer which is
02FF                          ; intended
02FF   7A                     MOV   A,D   
0300   B3                     ORA   E   
0301                DIVJZERROR:   
0301   CC D4 00               CZ   Error   
0304                          ; 
0304                DIVLOOP:   
0304   03                     INX   B   
0305   19                     DAD   D   
0306   1F                     RAR   ; look for mismatch between carry and
0307                          ; bit 7 of D to detect overflow/underflow
0307   AA                     XRA   D   
0308   F2 04 03               JP   DivLoop   
030B                          ; if HL is zero then it must have been a negative number originally, and the remainder is zero, so don't make any change to HL, but increment quotient by 1
030B                          ; 
030B   7C                     MOV   A,H   
030C   B5                     ORA   L   
        **MACRO UNROLL - RST_JZPAGE
030D   E7 RST   4   ; assume it is on same page
030E                          ; because DivSub will
030E                          ; be right at end of page 2
030E   11                     DB   (DivNoRestore&0ffh)-1   
030F                          ; 
        **MACRO UNROLL - RST_NEGATEDE
030F   F7 RST   6   
0310   19                     DAD   D   
0311   0B                     DCX   B   
0312                          ; 
0312                DIVNORESTORE:   
0312   03                     INX   B   
0313   50                     MOV   D,B   
0314   59                     MOV   E,C   
0315                          ; 
0315   C1                     POP   B   
0316                          ; 
0316   F1                     POP   PSW   
0317   F0                     RP   
        **MACRO UNROLL - RST_NEGATEDE
0318   F7 RST   6   
0319                          ; 
0319   C9                     RET   
031A                          ; 
031A                          ; GetLine sits entirely in page 3
031A                          ; good - it uses RST_CompareJump in two
031A                          ; places, so be careful if moving it
031A                          ; Also it assumes ClassLookup on same page
031A                          ; as NoCharClass
031A                NLTESTTRUE:   
031A                          ; A contains 13 at this point
031A                          ; we want to ooutput line feed (10)
031A                          ; because H is 3, we can subtract this from A
031A   94                     SUB   H   
        **MACRO UNROLL - RST_PUTCHAR
031B   CF RST   1   
031C                          ; 
031C                          ; error if we are in the middle
031C                          ; of a string
031C   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
031D   DF RST   3   
031E   6C                     DB   QuoteClassExpEnd&0ffh   
031F   00                     DB   (DivJZError-1)&0ffh   
0320                          ; 
0320   E1                     POP   H   
0321                          ; 
0321   C9                     RET   
0322                GETLINE:   
0322                          ; HL points where we want the line to be
0322                          ; parsed to.
0322                          ; On return HL points to byte after what we've
0322                          ; got.
0322                          ; 
0322   3E 3E                  MVI   A,'>'   
        **MACRO UNROLL - RST_PUTCHAR
0324   CF RST   1   
0325                GETLINENOPROMPT:   
0325   E5                     PUSH   H   
0326                          ; 
0326                          ; A is zero at this point
0326                          ; (needs to be <>newline character on fall
0326                          ; through to NLTest)
0326                FRESHSTART:   
0326   21 55 03               LXI   H,NoCharClass   
0329                          ; 
0329                NLTEST:   
0329   78                     MOV   A,B   
032A                          ; check for newline
        **MACRO UNROLL - RST_COMPAREJUMP
032A   DF RST   3   
032B   0D 19                  DB   13,(NLTestTrue&0ffh)-1   
032D                          ; 
032D                NEXTCHARLOOP:   
032D                          ; This code is compatable with Stefan Tramm's
032D                          ; 8080 emulator
032D   DB 00                  IN   0   
032F   A7                     ANA   A   
        **MACRO UNROLL - RST_JZPAGE
0330   E7 RST   4   
0331   2C                     DB   (NextCharLoop&0ffh)-1   
0332   DB 01                  IN   1   
0334   47                     MOV   B,A   
0335   D3 01                  OUT   1   ; echo
0337                          ; 
0337                          ; Do we have the same class as before?
0337   E5                     PUSH   H   
0338   2E AA                  MVI   L,(ClassLookup&0ffh)-1   
033A                          ; Test for quote first
033A                          ; This doesn't save spave, but takes 3 bytes
033A                          ; away from class lookip and puts them here
033A                          ; so can be used to change odd/even of
033A                          ; ...Class subroutines
        **MACRO UNROLL - RST_COMPAREJUMP
033A   DF RST   3   
033B   22 42                  DB   34,(LC_QuoteTestTrue-1)&0ffh   
033D                LOOKUPCLASSLOOP:   
033D   2C                     INR   L   
033E   BE                     CMP   M   
033F   2C                     INR   L   
0340   DA 3D 03               JC   LookupClassLoop   
0343                LC_QUOTETESTTRUE:   
0343   4E                     MOV   C,M   
0344   E1                     POP   H   
0345                          ; 
0345                          ; are L and C equal?
0345   7D                     MOV   A,L   
0346   A9                     XRA   C   
0347                          ; Z if they are equal, NZ if not
0347   E9                     PCHL   ; Jump based on previous CharClass pointer
0348                DIGITCLASS:   
        **MACRO UNROLL - RST_JZPAGE
0348   E7 RST   4   
0349   59                     DB   (DigitClassNotEnd&0ffh)-1   
034A                DIGITCLASSEND:   
034A                          ; Write token into program
034A                          ; need to preserve DE, don't care about HL
034A   E3                     XTHL   
034B   36 20                  MVI   M,IntegerToken   
034D   23                     INX   H   
034E   73                     MOV   M,E   
034F   23                     INX   H   
0350   36                     DB   36h   ; opcode for MVI M eats next byte
0351                WRITE_SHARED_ATSP:   
0351   D1                     POP   D   
0352                WRITE_SHARED:   
0352   72                     MOV   M,D   
0353                WRITE_SHARED_WRITTEN:   
0353   23                     INX   H   
0354   E3                     XTHL   
0355                NOCHARCLASS:   
0355   69                     MOV   L,C   
0356   AF                     XRA   A   ; set Z
0357   57                     MOV   D,A   ; reset state information
0358   5F                     MOV   E,A   
0359   E9                     PCHL   
035A                DIGITCLASSNOTEND:   
035A   E5                     PUSH   H   
035B                          ; A is zero at this point
035B                          ; Accumulate the value into D
035B                          ; Muliply by 10
035B   62                     MOV   H,D   
035C   6B                     MOV   L,E   
035D                          ; 
035D   29                     DAD   H   
035E   29                     DAD   H   
035F   19                     DAD   D   
0360   29                     DAD   H   
0361                          ; 
0361                          ; Add in the new digit
0361                          ; 
0361   57                     MOV   D,A   
0362   78                     MOV   A,B   
0363   E6 0F                  ANI   0fh   
0365   5F                     MOV   E,A   
0366   19                     DAD   D   
0367                          ; 
0367   EB                     XCHG   
0368                          ; 
0368   E1                     POP   H   
0369                          ; 
0369   C3 2D 03               JMP   NextCharLoop   
036C                QUOTECLASSEXPEND:   
036C                          ; A is equal to:
036C                          ; char class (C) XOR QuoteCharClassExpEnd
036C                          ; 
036C                          ; so long as QuoteCharClass is the only class
036C                          ; with an odd address or the only one
036C                          ; with an even address then A will only
036C                          ; have LSB=1 if current char class
036C                          ; is QuoteCharClass - i.e. end of string
036C                          ; 
036C   E6                     DB   0e6h   ; opcode for ANI eats next byte
036D                          ; (which is 2dh lsbits are 01)
036D                          ; 
036D                QUOTECLASS:   
036D   2D                     DCR   L   ; set to QuoteClassExpEnd
036E                          ; first time through A is zero
036E                          ; on fall A is even unless C is QuoteClass
036E                          ; 
036E   A4                     ANA   H   ; H is 3
036F                          ; 
036F                          ; Now Z is set if this was first Quote, or if
036F                          ; we are in a string and haven't reached
036F                          ; last quote
036F                          ; 
036F                          ; carry is clear here
036F   DA                     DB   0dah   ; opcode for JC eats next 2 bytes
0370                LT0CLASS:   
0370   23                     INX   H   ; next char should always count as
0371                          ; different class
0371   00                     NOP   
0372                COMPCLASS:   
0372   00                     NOP   
0373   00                     NOP   
0374                ALPHACLASS:   
0374                          ; 
0374   E3                     XTHL   
0375   70                     MOV   M,B   
0376   23                     INX   H   
0377   E3                     XTHL   
0378                          ; 
0378   1B                     DCX   D   ; increase char count
0379                          ; 
0379                          ; if NZ then we will just
0379                          ; have written a different class char:
0379                          ; good, this ensures no spurious
0379                          ; strcmp matches from leftover
0379                          ; buffer contents
0379                          ; 
0379                          ; now we need to decide whether to jump to:
0379                          ; FreshStart - if its the last quote in
0379                          ;							 a string
0379                          ; NLTest		 - if part way through string or
0379                          ;								token
0379                          ; TokenClassEnd - if end of token
0379                          ; 
        **MACRO UNROLL - RST_JZPAGE
0379   E7 RST   4   
037A   28                     DB   (NLTest&0ffh)-1   
037B                          ; 
037B   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
037C   DF RST   3   
037D   6C 25                  DB   QuoteClassExpEnd&0ffh,(FreshStart&0ffh)-1   
037F                          ; 
037F                TOKENCLASSEND:   
037F                          ; Make H point to the start of the token
037F                          ; to be looked up
037F   E3                     XTHL   
0380   19                     DAD   D   
0381                          ; 
0381                          ; it's a var if bits 7,6,5 are 010 and
0381                          ; E=-2
0381                          ; These aren't the only conditions that
0381                          ; could lead to the test below passing -
0381                          ; e.g. if 7,6,5=001 and E=10011110. But E
0381                          ; has to be large for this to happen, so
0381                          ; quite unlikely in practice.
0381   7E                     MOV   A,M   
0382   EE 40                  XRI   040h   
0384   57                     MOV   D,A   
0385   E6 E0                  ANI   0e0h   
0387   AB                     XRA   E   
0388                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
0388   DF RST   3   
0389   FE 51                  DB   0feh,(Write_Shared&0ffh)-1   
038B                          ; 
038B   11 B5 01               LXI   D,TokenList   
038E                LOOKUPTOKEN_LOOP:   
038E   1A                     LDAX   D   
038F   F5                     PUSH   PSW   
0390   E5                     PUSH   H   
0391                STRCMP:   
0391   13                     INX   D   
0392   1A                     LDAX   D   
0393   AE                     XRA   M   
0394                          ; iff match then A is either 00h or 80h
0394                          ; (80h if last char)
0394   23                     INX   H   
        **MACRO UNROLL - RST_JZPAGE
0395   E7 RST   4   
0396   90                     DB   (Strcmp&0ffh)-1   ; match and not last char
0397                          ; 
0397                          ; equal to 080h iff match and last char
0397   EE 80                  XRI   080h   
0399                          ; equal to Z iff match and last char
0399   E1                     POP   H   
039A                          ; 
        **MACRO UNROLL - RST_JZPAGE
039A   E7 RST   4   
039B   50                     DB   (Write_Shared_AtSP&0ffh)-1   
039C                          ; 
039C   F1                     POP   PSW   
039D                          ; 
039D                LOOKUPTOKEN:   
039D   1A                     LDAX   D   
039E   3C                     INR   A   
039F   13                     INX   D   
03A0   FA 8E 03               JM   LookupToken_Loop   
03A3   C2 9D 03               JNZ   LookupToken   
03A6                          ; 
03A6                          ; didn't find it
03A6                          ; if (HL)>=64 and (HL+1)<64 then its a var
03A6                          ; could do the var test here
03A6                          ; if it can be done in few bytes
03A6                          ; 
03A6   36 21                  MVI   M,QuestionMarkToken&0ffh   
        **MACRO UNROLL - RST_JZPAGE
03A8   E7 RST   4   
03A9   52                     DB   (Write_Shared_Written&0ffh)-1   
03AA   6D                     DB   QuoteClass&0ffh   
03AB                CLASSLOOKUP:   
03AB   40 74                  DB   64,AlphaClass&0ffh   
03AD   3A 72                  DB   58,CompClass&0ffh   
03AF   30 48                  DB   48,DigitClass&0ffh   
03B1   21 70                  DB   33,LT0Class&0ffh   
03B3   00 26                  DB   0,FreshStart&0ffh   
03B5                GETLINENUM:   
03B5                          ; Line number is in DE, look it up in the
03B5                          ; program and set BC to point to the LinenumSub
03B5                          ; token.
03B5                          ; 
03B5                          ; DE is preserved
03B5                          ; H is preserved
03B5                          ; L is not preserved
03B5                          ; 
03B5                          ; return with Z set if successful
03B5                          ; 
03B5                          ; Z clear if not successful, and BC points
03B5                          ; to the first byte of the line with number
03B5                          ; greater than the request
03B5                          ; 
03B5   01 3F 04               LXI   B,PROG_BASE-1   ; 1 bytes before PROG_BASE
03B8                GETLINENUMLOOP:   
03B8   CD D1 03               CALL   ATNLN_INXB   ; has one INX B preceeding
03BB   C0                     RNZ   
03BC                          ; 
03BC   03                     INX   B   
03BD                          ; 
03BD                          ; Test for DE <= (BC), and return if true
03BD   0A                     LDAX   B   
03BE   03                     INX   B   
03BF   93                     SUB   E   
03C0   6F                     MOV   L,A   
03C1   0A                     LDAX   B   
03C2   9A                     SBB   D   ; C set if DE > (BC), and Z not set
03C3                          ; C clear if DE <= (BC)
03C3   DA B8 03               JC   GetLineNumLoop   
03C6                          ; 
03C6   0B                     DCX   B   
03C7   0B                     DCX   B   
03C8                          ; Now we want Z set if DE=(BC), clear
03C8                          ; otherwise
03C8                          ; 
03C8                ATNLN_RETNZ:   ; shared code. Returns NZ if we know
03C8                          ; that A is non-zero
03C8   B5                     ORA   L   
03C9                          ; 
03C9   C9                     RET   
03CA                ATNLN_STRING:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
03CA   D7 RST   2   
03CB   22                     DB   StringToken   
03CC   C2 CA 03               JNZ   ATNLN_String   
03CF                          ; 
03CF   C2                     DB   0c2h   ; opcode for JNZ eats 2 bytes
03D0                ATNLN_INT:   ; Z is always set when we reach here
03D0   03                     INX   B   
03D1                ATNLN_INXB:   
03D1   03                     INX   B   
03D2                          ; 
03D2                ADVANCETONEXTLINENUM:   
03D2                          ; BC is a pointer to somewhere in the program.
03D2                          ; Move onto the next line number.
03D2                          ; Return with Z set if successful,
03D2                          ; Z clear if fell off end of program
03D2   0A                     LDAX   B   
        **MACRO UNROLL - RST_COMPAREJUMP
03D3   DF RST   3   
03D4   87 C7                  DB   EndProgram&0ffh,(ATNLN_RetNZ&0ffh)-1   
03D6                          ; fell off end of program
03D6                          ; 
03D6   FE 28                  CPI   LinenumSub&0ffh   
03D8   C8                     RZ   
03D9                          ; 
03D9   03                     INX   B   
03DA                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
03DA   DF RST   3   
03DB   20 CF                  DB   IntegerToken,(ATNLN_Int&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
03DD   DF RST   3   
03DE   22 C9                  DB   StringToken,(ATNLN_String&0ffh)-1   
03E0   C3 D2 03               JMP   AdvanceToNextLineNum   
03E3                FORSUBIMPL:   
03E3                          ; Stack contains return address:
03E3                          ; ExecuteProgramLoop - EPL
03E3                          ; Keep it there even though it isn't used by
03E3                          ; ForSub, it will be used by NextSub
03E3                          ; 
03E3   E5                     PUSH   H   ; stack contains <SP> VL+1, EPL
03E4                          ; 
03E4                          ; check that we have a 'TO' token
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
03E4   D7 RST   2   
03E5   A3                     DB   ToToken&0ffh   
03E6   C4 D4 00               CNZ   Error   
03E9                          ; 
        **MACRO UNROLL - RST_EXPEVALUATE
03E9   FF RST   7   
        **MACRO UNROLL - RST_NEGATEDE
03EA   F7 RST   6   
03EB                          ; 
03EB   D5                     PUSH   D   ; stack contains <SP> -T,VL+1, EPL
03EC                          ; T is target
03EC                          ; 
03EC                          ; step is going to be 1 unless we encounter
03EC                          ; a STEP token
03EC   11 01 00               LXI   D,1   
03EF   0A                     LDAX   B   
03F0                          ; 
03F0                          ; check for optional STEP token
        **MACRO UNROLL - RST_COMPAREJUMP
03F0   DF RST   3   
03F1   A4 F3                  DB   StepToken&0ffh,(ForWithStep&0ffh)-1   
03F3   21                     DB   21h   ; LXI H opcode eats the next 2 bytes
03F4                FORWITHSTEP:   
03F4                          ; we have step token
03F4   03                     INX   B   
        **MACRO UNROLL - RST_EXPEVALUATE
03F5   FF RST   7   
03F6                          ; 
03F6   E1                     POP   H   
03F7   E1                     POP   H   ; H contains VL+1
03F8                          ; 
03F8                          ; B contains the start address of the
03F8                          ; loop (LS)
03F8                          ; 
03F8   C5                     PUSH   B   ; stack contains -T <SP> LS,EPL
03F9   3B                     DCX   SP   
03FA   3B                     DCX   SP   ; stack contains <SP> -T,LS,EPL
03FB   D5                     PUSH   D   ; stack contains <SP>,S,-T,LS,EPL
03FC   E5                     PUSH   H   ; stack contains <SP>,VL+1,S,-T,LS,EPL
03FD                          ; 
03FD   C3 90 02               JMP   ExecuteProgramLoop   
0400                          ; 


RAM_BASE:           0400 DEFINED AT LINE 351
                    > USED AT LINE 381
                    > USED AT LINE 385
                    > USED AT LINE 388
                    > USED AT LINE 389
                    > USED AT LINE 391
RAM_TOP:            0800 DEFINED AT LINE 352
                    > USED AT LINE 377
                    > USED AT LINE 378
INTEGERTOKEN:       0020 DEFINED AT LINE 358
                    > USED AT LINE 569
                    > USED AT LINE 844
                    > USED AT LINE 1014
                    > USED AT LINE 1688
                    > USED AT LINE 1952
QUESTIONMARKTOKEN:  0021 DEFINED AT LINE 359
                    > USED AT LINE 1117
                    > USED AT LINE 1868
STRINGTOKEN:        0022 DEFINED AT LINE 360
                    > USED AT LINE 672
                    > USED AT LINE 678
                    > USED AT LINE 761
                    > USED AT LINE 1010
                    > USED AT LINE 1926
                    > USED AT LINE 1954
INPUT_BUFFER:       07F8 DEFINED AT LINE 377
                    > USED AT LINE 1230
STACK_INIT:         07F8 DEFINED AT LINE 378
                    > USED AT LINE 815
                    > USED AT LINE 1217
VAR_SPACE:          0400 DEFINED AT LINE 381
                    > USED AT LINE 733
PROG_PTR:           0400 DEFINED AT LINE 385
                    > USED AT LINE 413
                    > USED AT LINE 823
                    > USED AT LINE 864
                    > USED AT LINE 930
PROG_PARSE_PTR:     043C DEFINED AT LINE 388
                    > USED AT LINE 746
                    > USED AT LINE 831
                    > USED AT LINE 883
RNG_SEED:           043E DEFINED AT LINE 389
                    > USED AT LINE 1407
                    > USED AT LINE 1412
PROG_BASE:          0440 DEFINED AT LINE 391
                    > USED AT LINE 1328
                    > USED AT LINE 1369
                    > USED AT LINE 1895
PUTCHAR:            0008 DEFINED AT LINE 424
PUTCHARWAITLOOP:    000A DEFINED AT LINE 433
COMPAREJUMP_ENTRY:  0021 DEFINED AT LINE 483
                    > USED AT LINE 474
JZPAGE_SKIP:        0025 DEFINED AT LINE 486
                    > USED AT LINE 484
EXPAPPLYOP:         0026 DEFINED AT LINE 488
                    > USED AT LINE 612
                    > USED AT LINE 627
COMPAREHLDE:        0028 DEFINED AT LINE 497
NEGATEDE:           0030 DEFINED AT LINE 516
EXPEVALUATE:        0038 DEFINED AT LINE 540
EXPEVALUATENUM:     003C DEFINED AT LINE 552
                    > USED AT LINE 547
                    > USED AT LINE 662
EXPINTEGER:         0055 DEFINED AT LINE 578
EXPVAR:             0059 DEFINED AT LINE 585
                    > USED AT LINE 570
EXPVARGETVALUE:     005C DEFINED AT LINE 589
EXPEVALUATEOP:      005F DEFINED AT LINE 594
                    > USED AT LINE 652
                    > USED AT LINE 773
SKIPEXPAPPLYOP:     006E DEFINED AT LINE 630
                    > USED AT LINE 606
EXPNEGATE:          0075 DEFINED AT LINE 647
                    > USED AT LINE 560
PRINTSUBLOOP:       0084 DEFINED AT LINE 664
                    > USED AT LINE 703
PRINTSUBIMPL:       0084 DEFINED AT LINE 665
                    > USED AT LINE 1198
PRINTSUBEXPRESSION: 008F DEFINED AT LINE 687
PRINTSUBSTRING:     0094 DEFINED AT LINE 693
                    > USED AT LINE 674
PRINTSUBEND:        009E DEFINED AT LINE 708
                    > USED AT LINE 685
CRLF:               009F DEFINED AT LINE 711
                    > USED AT LINE 800
                    > USED AT LINE 817
                    > USED AT LINE 1045
GETVARLOCATIONBVAR: 00A6 DEFINED AT LINE 718
                    > USED AT LINE 1227
                    > USED AT LINE 1241
GETVARLOCATION:     00AB DEFINED AT LINE 725
                    > USED AT LINE 588
OUTPUTSTRINGRET:    00B9 DEFINED AT LINE 751
                    > USED AT LINE 763
OUTPUTSTRING:       00BA DEFINED AT LINE 756
                    > USED AT LINE 694
OUTPUTSTRINGLOOP:   00BB DEFINED AT LINE 759
                    > USED AT LINE 767
OUTPUTSTRING_WITHQUOTE: 00BF DEFINED AT LINE 764
                    > USED AT LINE 1097
EXPLEFTBRACE:       00C2 DEFINED AT LINE 769
                    > USED AT LINE 558
FUNCTIONCALL:       00C3 DEFINED AT LINE 771
                    > USED AT LINE 567
EXPBRACKETEDB:      00CB DEFINED AT LINE 785
                    > USED AT LINE 741
ERROR:              00D4 DEFINED AT LINE 799
                    > USED AT LINE 564
                    > USED AT LINE 575
                    > USED AT LINE 723
                    > USED AT LINE 788
                    > USED AT LINE 874
                    > USED AT LINE 1212
                    > USED AT LINE 1219
                    > USED AT LINE 1248
                    > USED AT LINE 1342
                    > USED AT LINE 1555
                    > USED AT LINE 1968
READY:              00DE DEFINED AT LINE 810
                    > USED AT LINE 1318
                    > USED AT LINE 1329
READYNONEWLINE:     00E4 DEFINED AT LINE 821
                    > USED AT LINE 899
                    > USED AT LINE 942
LINESTARTSWITHINT:  00FB DEFINED AT LINE 847
DELETEPROGRAMLINE:  011C DEFINED AT LINE 895
                    > USED AT LINE 869
ENTRY:              012C DEFINED AT LINE 925
                    > USED AT LINE 893
MEMORYROTATE:       0130 DEFINED AT LINE 932
REVERSEDH:          013A DEFINED AT LINE 945
                    > USED AT LINE 940
REVERSE:            013D DEFINED AT LINE 950
                    > USED AT LINE 939
REVERSELOOP:        013D DEFINED AT LINE 954
                    > USED AT LINE 968
POPHASSIGNTOVAR_PREFIX: 014B DEFINED AT LINE 970
                    > USED AT LINE 1233
POPHASSIGNTOVAR:    0152 DEFINED AT LINE 981
                    > USED AT LINE 1252
LISTLOOP:           0157 DEFINED AT LINE 993
                    > USED AT LINE 1001
                    > USED AT LINE 1370
LIST_TOKEN_LOOP:    016F DEFINED AT LINE 1021
                    > USED AT LINE 1025
                    > USED AT LINE 1032
LIST_TOKEN:         0175 DEFINED AT LINE 1027
LIST_TOKEN_STRING_LOOP: 017A DEFINED AT LINE 1034
                    > USED AT LINE 1040
LIST_LINENUM:       0184 DEFINED AT LINE 1044
                    > USED AT LINE 1012
LIST_INTEGER:       0187 DEFINED AT LINE 1047
                    > USED AT LINE 1014
PRINTINTEGER:       018D DEFINED AT LINE 1057
                    > USED AT LINE 689
                    > USED AT LINE 804
PRINTINTEGERLOOP:   0198 DEFINED AT LINE 1069
                    > USED AT LINE 1064
                    > USED AT LINE 1087
PRINTINTEGERLOOP2:  01A8 DEFINED AT LINE 1089
                    > USED AT LINE 1094
LIST_STRING:        01AD DEFINED AT LINE 1096
                    > USED AT LINE 1010
LIST_VAR:           01B1 DEFINED AT LINE 1100
                    > USED AT LINE 1016
TOKENLIST:          01B5 DEFINED AT LINE 1116
                    > USED AT LINE 1005
                    > USED AT LINE 1828
LINENUMSUB:         0228 DEFINED AT LINE 1192
                    > USED AT LINE 881
                    > USED AT LINE 1012
                    > USED AT LINE 1337
                    > USED AT LINE 1341
                    > USED AT LINE 1346
                    > USED AT LINE 1946
PRINTSUB:           022B DEFINED AT LINE 1197
                    > USED AT LINE 659
                    > USED AT LINE 778
                    > USED AT LINE 1119
GOSUBSUB:           022E DEFINED AT LINE 1200
                    > USED AT LINE 1125
GOTOSUB:            0233 DEFINED AT LINE 1208
                    > USED AT LINE 1123
RETURNSUB:          023B DEFINED AT LINE 1214
                    > USED AT LINE 1127
INPUTSUB:           0245 DEFINED AT LINE 1225
                    > USED AT LINE 1129
FORSUB:             0250 DEFINED AT LINE 1235
                    > USED AT LINE 1131
LETSUB:             0254 DEFINED AT LINE 1240
                    > USED AT LINE 1121
NEXTSUB:            0261 DEFINED AT LINE 1254
                    > USED AT LINE 1133
NEXTSUBLOOP:        0279 DEFINED AT LINE 1298
                    > USED AT LINE 1292
IFSUB:              0281 DEFINED AT LINE 1308
                    > USED AT LINE 1135
ENDSUB:             0288 DEFINED AT LINE 1317
                    > USED AT LINE 1137
                    > USED AT LINE 1321
ENDPROGRAM:         0287 DEFINED AT LINE 1321
                    > USED AT LINE 829
                    > USED AT LINE 842
                    > USED AT LINE 868
                    > USED AT LINE 998
                    > USED AT LINE 1943
EXECUTEPROGRAM:     028B DEFINED AT LINE 1323
                    > USED AT LINE 411
                    > USED AT LINE 1141
EXECUTEPROGRAMLOOP: 0290 DEFINED AT LINE 1332
                    > USED AT LINE 1351
                    > USED AT LINE 2003
EXECUTEDIRECT:      0291 DEFINED AT LINE 1335
                    > USED AT LINE 845
NEWSUB:             02A1 DEFINED AT LINE 1364
                    > USED AT LINE 1145
LASTSTATEMENT:      02A2 DEFINED AT LINE 1367
                    > USED AT LINE 678
                    > USED AT LINE 1341
LISTSUB:            02A2 DEFINED AT LINE 1368
                    > USED AT LINE 1143
                    > USED AT LINE 1375
                    > USED AT LINE 1376
                    > USED AT LINE 1377
                    > USED AT LINE 1378
TOTOKEN:            02A3 DEFINED AT LINE 1375
                    > USED AT LINE 1160
                    > USED AT LINE 1967
STEPTOKEN:          02A4 DEFINED AT LINE 1376
                    > USED AT LINE 1162
                    > USED AT LINE 1983
RIGHTBRACETOKEN:    02A5 DEFINED AT LINE 1377
                    > USED AT LINE 793
                    > USED AT LINE 1168
COMMATOKEN:         02A6 DEFINED AT LINE 1378
                    > USED AT LINE 701
                    > USED AT LINE 1164
ABSSUB:             02A8 DEFINED AT LINE 1380
                    > USED AT LINE 566
                    > USED AT LINE 1153
                    > USED AT LINE 1537
LEFTBRACETOKEN:     02AB DEFINED AT LINE 1392
                    > USED AT LINE 556
                    > USED AT LINE 787
                    > USED AT LINE 1166
USRSUB:             02AC DEFINED AT LINE 1395
                    > USED AT LINE 1155
RNDSUB:             02AE DEFINED AT LINE 1400
                    > USED AT LINE 563
                    > USED AT LINE 1157
OPERATORS:          02C5 DEFINED AT LINE 1455
                    > USED AT LINE 636
LTESUB:             02C5 DEFINED AT LINE 1457
                    > USED AT LINE 1176
GTESUB:             02C6 DEFINED AT LINE 1460
                    > USED AT LINE 1174
GTSUB:              02C9 DEFINED AT LINE 1464
                    > USED AT LINE 1180
LTSUB:              02CA DEFINED AT LINE 1467
                    > USED AT LINE 1178
EQUALSUB:           02D3 DEFINED AT LINE 1478
                    > USED AT LINE 1170
                    > USED AT LINE 1247
BINRETURN:          02D4 DEFINED AT LINE 1480
                    > USED AT LINE 1463
NOTEQUALSUB:        02D6 DEFINED AT LINE 1484
                    > USED AT LINE 1172
ADDSUB:             02DD DEFINED AT LINE 1491
                    > USED AT LINE 1182
SUBSUB:             02DE DEFINED AT LINE 1493
                    > USED AT LINE 560
                    > USED AT LINE 1184
MULSUB:             02E2 DEFINED AT LINE 1501
                    > USED AT LINE 612
                    > USED AT LINE 1186
                    > USED AT LINE 1409
MULTIPLY:           02E5 DEFINED AT LINE 1508
MULLOOP:            02E7 DEFINED AT LINE 1511
                    > USED AT LINE 1521
DONTADD:            02EF DEFINED AT LINE 1518
                    > USED AT LINE 1516
DIVSUB:             02F6 DEFINED AT LINE 1527
                    > USED AT LINE 1188
DIVIDEHL:           02F6 DEFINED AT LINE 1533
                    > USED AT LINE 1076
                    > USED AT LINE 1419
DIVJZERROR:         0301 DEFINED AT LINE 1554
                    > USED AT LINE 1609
DIVLOOP:            0304 DEFINED AT LINE 1557
                    > USED AT LINE 1563
DIVNORESTORE:       0312 DEFINED AT LINE 1578
                    > USED AT LINE 1572
NLTESTTRUE:         031A DEFINED AT LINE 1597
                    > USED AT LINE 1640
GETLINE:            0322 DEFINED AT LINE 1615
                    > USED AT LINE 827
GETLINENOPROMPT:    0325 DEFINED AT LINE 1624
                    > USED AT LINE 974
FRESHSTART:         0326 DEFINED AT LINE 1632
                    > USED AT LINE 1802
                    > USED AT LINE 1878
NLTEST:             0329 DEFINED AT LINE 1636
                    > USED AT LINE 1798
NEXTCHARLOOP:       032D DEFINED AT LINE 1642
                    > USED AT LINE 1648
                    > USED AT LINE 1736
LOOKUPCLASSLOOP:    033D DEFINED AT LINE 1663
                    > USED AT LINE 1667
LC_QUOTETESTTRUE:   0343 DEFINED AT LINE 1668
                    > USED AT LINE 1662
DIGITCLASS:         0348 DEFINED AT LINE 1679
                    > USED AT LINE 1876
DIGITCLASSEND:      034A DEFINED AT LINE 1683
WRITE_SHARED_ATSP:  0351 DEFINED AT LINE 1693
                    > USED AT LINE 1851
WRITE_SHARED:       0352 DEFINED AT LINE 1695
                    > USED AT LINE 1826
WRITE_SHARED_WRITTEN: 0353 DEFINED AT LINE 1697
                    > USED AT LINE 1870
NOCHARCLASS:        0355 DEFINED AT LINE 1701
                    > USED AT LINE 1634
DIGITCLASSNOTEND:   035A DEFINED AT LINE 1709
                    > USED AT LINE 1681
QUOTECLASSEXPEND:   036C DEFINED AT LINE 1738
                    > USED AT LINE 1608
                    > USED AT LINE 1802
QUOTECLASS:         036D DEFINED AT LINE 1752
                    > USED AT LINE 1872
LT0CLASS:           0370 DEFINED AT LINE 1767
                    > USED AT LINE 1877
COMPCLASS:          0372 DEFINED AT LINE 1772
                    > USED AT LINE 1875
ALPHACLASS:         0374 DEFINED AT LINE 1775
                    > USED AT LINE 1874
TOKENCLASSEND:      037F DEFINED AT LINE 1804
LOOKUPTOKEN_LOOP:   038E DEFINED AT LINE 1830
                    > USED AT LINE 1859
STRCMP:             0391 DEFINED AT LINE 1834
                    > USED AT LINE 1842
LOOKUPTOKEN:        039D DEFINED AT LINE 1855
                    > USED AT LINE 1860
CLASSLOOKUP:        03AB DEFINED AT LINE 1873
                    > USED AT LINE 1655
GETLINENUM:         03B5 DEFINED AT LINE 1880
                    > USED AT LINE 862
                    > USED AT LINE 1210
GETLINENUMLOOP:     03B8 DEFINED AT LINE 1897
                    > USED AT LINE 1911
ATNLN_RETNZ:        03C8 DEFINED AT LINE 1918
                    > USED AT LINE 1943
ATNLN_STRING:       03CA DEFINED AT LINE 1924
                    > USED AT LINE 1927
                    > USED AT LINE 1954
ATNLN_INT:          03D0 DEFINED AT LINE 1930
                    > USED AT LINE 908
                    > USED AT LINE 1952
ATNLN_INXB:         03D1 DEFINED AT LINE 1932
                    > USED AT LINE 1898
ADVANCETONEXTLINENUM: 03D2 DEFINED AT LINE 1935
                    > USED AT LINE 1315
                    > USED AT LINE 1955
FORSUBIMPL:         03E3 DEFINED AT LINE 1957
                    > USED AT LINE 1236
FORWITHSTEP:        03F4 DEFINED AT LINE 1986
                    > USED AT LINE 1983